<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/static-clones/edx-platform/docs/concepts/frontend/static_assets.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="edx-platform-static-asset-pipeline-plan" names="edx-platform\ static\ asset\ pipeline\ plan">
        <title>edx-platform Static Asset Pipeline Plan</title>
        <paragraph>Static asset handling in edx-platform has evolved in a messy way over the years.
            This has led to a lot of complexity and inconsistencies. This is a proposal for
            how we can move forward to a simpler system and more modern toolchain. Note that
            this is not a detailed guide for how to write React or Bootstrap code. This is
            instead going to talk about conventions for how we arrange, extract, and compile
            static assets.</paragraph>
        <section ids="big-open-questions-todo" names="big\ open\ questions\ (todo)">
            <title>Big Open Questions (TODO)</title>
            <paragraph>This document is a work in progress, as the design for some of this is still in
                flux, particularly around extensibility.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Pluggable third party apps and Webpack packaging.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Keep the Django i18n mechanism?</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Stance on HTTP/2 and bundling granularity.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Optimizing theme assets.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Tests</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="requirements" names="requirements">
            <title>Requirements</title>
            <paragraph>Any proposed solution must support:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Externally developed and installed Django apps.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Theming.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>XBlock assets.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Existing tests.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Fast builds.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>An incremental implementation path.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Other kinds of pluggability???</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="assumptions" names="assumptions">
            <title>Assumptions</title>
            <paragraph>Some assumptions/opinions that this proposal is based on:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>We want to shift as much as possible to Webpack and the JavaScript stack of
                        technologies, leaving the Python layer as thin as possible.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>While we will try to make theming upgrades straightforward, we will be moving
                        around where files are located and where they’re compiled out to.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>We will be pushing towards a world that is more Django app-centric than LMS
                        vs. Studio centric, to reduce duplication.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>At the same time, we want to consolidate assets far more efficiently than we
                        are doing today.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Leaning towards more static front ends + API calls.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>However we still need to be compatible with Django’s asset system for things
                        like third party apps (e.g. Django Rest Framework browsing assets, Swagger,
                        etc.)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>It should be possible to pre-build static assets and deploy them onto S3 or
                        similar.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="where-we-are-today" names="where\ we\ are\ today">
            <title>Where We Are Today</title>
            <paragraph>We have a static asset pipeline that is mostly driven by Django’s built-in
                staticfiles finders and the collectstatic process. We use the popular
                <literal>django-pipeline</literal> library, with UglifyJS as the JavaScript compressor (the
                binary is installed via node into node_modules). We also use the less well known
                <literal>django-pipeline-forgiving</literal> extension to <literal>django-pipeline</literal> so we don’t error
                out when files are missing (added when we started dynamically scanning XBlocks
                for assets).</paragraph>
            <paragraph>The <literal>django-pipeline</literal> config is aware of CSS files for the purposes of
                concatenation, but it does <emphasis>not</emphasis> know about the source Sass files.
                Those are processed with paver tasks before <literal>django-pipeline</literal> ever sees them.</paragraph>
            <paragraph>We also have the following custom extensions to Django’s builtin <literal>STATICFILES</literal>
                mechanism:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>openedx.core.djangoapps.theming.finders.ThemeFilesFinder</literal></term>
                    <definition>
                        <paragraph>Custom finder that overrides any static asset with a version from the themes
                            directory (<literal>COMPREHENSIVE_THEME_DIRS</literal> defined in <literal>lms.yml</literal> and
                            <literal>studio.yml</literal>).</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>openedx.core.lib.xblock_pipeline.finder.XBlockPipelineFinder</literal></term>
                    <definition>
                        <paragraph>Custom finder that accesses and extracts assets from pip-installed XBlocks via
                            <literal>pkg_resources</literal>.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>openedx.core.storage.DevelopmentStorage/ProductionStorage</literal></term>
                    <definition>
                        <paragraph>Custom <literal>FileStorage</literal> classes that mostly exist for theme-awareness.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <section ids="lms-and-studio-cms-separation" names="lms\ and\ studio/cms\ separation">
                <title>LMS and Studio/CMS Separation</title>
                <paragraph>LMS and Studio have their own directories for source assets (<literal>lms/static</literal> and
                    <literal>cms/static</literal>), and have symlinks to shared assets in <literal>common/static</literal>. We
                    treat the static asset compilation and collection phase for LMS and Studio as
                    separate projects that happen to share a lot of pieces. They output to different
                    places (typically <literal>/edx/var/edxapp/staticfiles</literal> for LMS and
                    <literal>/edx/var/edxapp/staticfiles/studio</literal> for Studio) and can be collected
                    separately. However in practice they’re always run together because we deploy
                    them from the same commits and to the same servers.</paragraph>
            </section>
        </section>
        <section ids="django-vs-webpack-conventions" names="django\ vs.\ webpack\ conventions">
            <title>Django vs. Webpack Conventions</title>
            <paragraph>The Django convention for having an app with bundled assets is to namespace them
                locally with the app name so that they get their own directories when they are
                gathered together into a common static directory by collectstatic. For example,
                the edx-enterprise app has a <literal>static/enterprise</literal> folder, so its assets are
                compiled to <literal>/edx/var/edxapp/staticfiles/enterprise</literal> by edx-platform and will
                not conflict with assets from any other Django app.</paragraph>
            <paragraph>Webpack conventions would have us create a single set of configuration files at
                the root of edx-platform, which would specify all bundles in the project.</paragraph>
            <paragraph>TODO: The big, “pluggable Webpack components” question.</paragraph>
        </section>
        <section ids="proposed-repo-structure" names="proposed\ repo\ structure">
            <title>Proposed Repo Structure</title>
            <paragraph>All assets that are in common spaces like <literal>common/static</literal>, <literal>lms/static</literal>,
                and <literal>cms/static</literal> would be moved to be under the Django apps that they are a
                part of and follow the Django naming convention (e.g.
                <literal>openedx/features/course_bookmarks/static/course_bookmarks</literal>). An app’s
                <literal>templates/{appname}</literal> directory will only be for server side templates, and
                any client-side templates will be put in <literal>static/{appname}/templates</literal>.</paragraph>
        </section>
        <section ids="proposed-compiled-structure" names="proposed\ compiled\ structure">
            <title>Proposed Compiled Structure</title>
            <paragraph>This is meant to be a sample of the different types of things we’d have, not a
                full list:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve"># Webpack bundles/post-processed assets
/webpack/css
        /fonts
        /js
        /vendor ?

# Django apps that are in the edx-platform repo
/course_bookmarks
/course_experience

# edX authored, installed via separate repo
/enterprise

# Entirely third party apps that we need to maintain compatiblity with.
/admin
/rest_framework

# Themes are part of the "theming" app
/theming/themes/open-edx
               /red-theme
               /edx.org

# XBlocks still collect their assets into a common space (/xmodule goes away)
# We consider this to be the XBlock Runtime's app, and it collects static
# assets from installed XBlocks.
/xblock</literal_block>
        </section>
        <section ids="django-vs-webpack-roles" names="django\ vs.\ webpack\ roles">
            <title>Django vs. Webpack Roles</title>
            <paragraph>Rule of thumb: Django/Python still serves static assets, Webpack processes and
                optimizes them.</paragraph>
            <paragraph>Webpack would be responsible for all Sass compilation in edx-platform. It would
                also be responsible for the optimization/minification of JavaScript assets, but
                those optimized assets would only appear under the <literal>/webpack</literal> directory. Third
                party assets that Webpack is not aware of may have hash suffixes applied to them
                by the Django collectstatic layer, but will not otherwise be processed or
                optimized in any way – so no sass compilation, no uglifyjs minification, etc.</paragraph>
            <paragraph>The django-pipeline dependency should be removed altogether.</paragraph>
            <section ids="themes" names="themes">
                <title>Themes</title>
                <paragraph>Theme handling is muddled. The fact that themes can override server-side
                    templates means that Python has to be aware of them. At the same time, we want
                    to shift over Sass compilation as a whole to Webpack, meaning that at least some
                    knowledge about where they are and how to compile them has to exist there. Also,
                    there are JS assets in some themes that provide additional functionality, and it
                    would be a performance degradation if those assets were no longer optimized.</paragraph>
                <paragraph>What I do NOT want to happen:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Significant end user performance degradation.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Having an <emphasis>additional</emphasis> system in the asset pipeline (e.g. keeping
                            django-pipeline around while having additional systems).</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>I think that means that conceptually, there exists a larger Static Asset system
                    that exists and that we think of both Webpack and Django being consumers of its
                    configuration. This is also very fuzzy at the moment.</paragraph>
            </section>
            <section ids="asset-groups" names="asset\ groups">
                <title>Asset Groups</title>
                <paragraph>There will be logical groupings of static assets. There should be uniformity and
                    no duplication within a group, but we would allow duplication between groups to
                    better facilitate independent deployment and isolation.</paragraph>
                <paragraph>Example Groups:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>XBlock/XModule Assets</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>LMS/Studio apps in edx-platform</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Third party app, such as edx-enterprise</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
    </section>
</document>
