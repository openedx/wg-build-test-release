<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/static-clones/edx-platform/docs/references/docs/lms/djangoapps/grades/docs/decisions/0001-gradebook-api.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="gradebook-read-and-write-apis" names="gradebook\ read\ and\ write\ apis">
        <title>Gradebook read and write APIs</title>
        <section ids="status" names="status">
            <title>Status</title>
            <paragraph>Accepted</paragraph>
        </section>
        <section ids="context" names="context">
            <title>Context</title>
            <paragraph>We are implementing a “Writable Gradebook” feature from the instructor dashboard.
                This feature supports both the reading of subsection grades (e.g. for HW assignments, Labs, Exams)
                and the creation/modification of subsection grades from a user interface.  This document captures
                decisions related to the design of the Django APIs that support this feature.</paragraph>
        </section>
        <section ids="decisions" names="decisions">
            <title>Decisions</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Feature-gating</strong></paragraph>
                    <enumerated_list enumtype="loweralpha" prefix="" suffix=".">
                        <list_item>
                            <paragraph>This feature will be gated behind a <title_reference>CourseWaffleFlag</title_reference>.  This will allow us to roll out to a few courses
                                as a time and to defer decisions that may need to be made about the scalability of this feature when
                                applied to courses with a massive number (i.e. hundreds of thousands) of enrollments.  We can eventually
                                remove the check for this flag.  When the flag is not enabled for a course, the endpoints will provide a
                                response and status code indicating as much.</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
                <list_item>
                    <paragraph><strong>The read (GET) API</strong></paragraph>
                    <enumerated_list enumtype="loweralpha" prefix="" suffix=".">
                        <list_item>
                            <paragraph>The read API supports either fetching subsection scores for a single user via <literal>?username=my-user-name</literal>,
                                where we look up a user by their exact <literal>username</literal> value; via <literal>?username_contains=name-substring</literal> where
                                we do a case-insensitive substring query for a user, or fetching a paginated result of
                                subsection grade data for all enrollees in the requested course.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The schema of results includes information about the overall course grade as well as a “breakdown”
                                of user grades for each graded subsection in the course.  The schema provides data needed by the client-side
                                code; the client-side code is in charge of determining how to display that data (e.g. how many decimal
                                places to round a percentage to).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We will use the Django Rest Framework <title_reference>CursorPagination</title_reference> class as the base pagination class for all students’ data
                                in a course.  The query set that we paginate is the set of active enrollees for the requested course.  As a result
                                of using this pagination class, paginated responses will not contain a <title_reference>count</title_reference> key, and the pagination query
                                parameter <title_reference>cursor</title_reference> will have very opaque values.  We have added a <literal>get_page_size</literal> method to this
                                class to allow clients to specify how many user results they would like in one page of data.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The same pagination class as above is used as the pagination class for the <title_reference>CourseGradesView</title_reference> API.  This is for
                                consistency, and also so that responses from this endpoint will be properly paginated (they previously contained
                                only the paginated data, and relied on the client “knowing” that further pages were available by using the
                                <title_reference>?page=N</title_reference> query parameter).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We follow the approach of instructor Grade Reports for determining user subsection grade data.
                                We collect the entire course structure once at the begining of course grade iteration and use that structure
                                for reading subsection grades of all users.  We do this for performance reasons; we explicitly avoid
                                fetching user-specific course structures, which is a costly operation.  One implication of this is that,
                                for a user with no persisted subsection grade, we cannot determine the true possible number of points
                                in that subsection as it relates to that user; it’s possible the subsection is not visible to the user, or
                                that certain problem blocks within the subsection are not visible to the user.  Since we cannot determine
                                this possible number of points, all subsection grades where no attempt has been made by the user
                                are assigned an earned/possible ratio of <literal>0/0</literal>.</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
                <list_item>
                    <paragraph><strong>The write (POST) API</strong></paragraph>
                    <enumerated_list enumtype="loweralpha" prefix="" suffix=".">
                        <list_item>
                            <paragraph>The write API will be a <title_reference>bulk-update</title_reference> endpoint that allows for the creation/modification of subsection
                                grades for multiple users and sections in a single request.  This allows clients of the API to limit
                                the number of network requests made and to more easily manage client-side data.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The write API will act as a <title_reference>create-or-update</title_reference> endpoint.  That is, if a persistent subsection grade record
                                does not currently exist for a given user/subsection that the client intends to update, part of the
                                request involves creating a corresponding persistent subsection grade record in addition to creating an override
                                associated with that grade.  We do this because our grading system makes an assumption that a subsection’s
                                grade value is 0 if no record for that subsection exists, and therefore, a client reading grade data
                                cannot make a distinction if a given subsection grade is 0 because no attempt or record exists, or if
                                there is a recorded score somewhere of zero.  This should be completely opaque to that client, and thus,
                                we create a grade if necessary in this endpoint.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We won’t fail the entire request if one item in the batch data raises an exception.  Instead, we will
                                report the status (as a boolean value) for each requested grade override item in the request back to the client,
                                along with a reason for items that have <literal>success: false</literal> entry.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A status code of <literal>422</literal> will be returned for requests that contain any failed item.  This allows a client
                                to easily tell if any item in their request payload was problematic and needs special handling.  If all
                                requested items succeed, a <literal>202 (accepted)</literal> is returned.  This status code was chosen because a
                                celery task is enqueued and waited for each subsection grade that needs to be updated.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We have to thread a <literal>force_update_subsections</literal> keyword argument into the subsection update task that
                                we enqueue.  This is because we may be creating a new subsection grade with no score data available from
                                either <literal>courseware.StudentModule</literal> records or from the <title_reference>Submissions</title_reference> API. In this case, the only score
                                data available exists in the grade override record, and the subsection <literal>update()</literal> call should be forced
                                to read from this record.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We have to synchronously update each grade record for each user in this endpoint. This means POST requests
                                will be open long enough for the override to be created and for all course/subsection grades
                                to be updated for each user. The primary consumer gradebook UI needs to display the updated grade
                                result for all users, after update is complete. If we do update asynchronously, the gradebook UI
                                won’t know how to update the table with new values for affected users’ grades.
                                This is the lowest effort change to address the UI display problem. We will
                                need to improve this mechanism as we continue to develop.</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
            </enumerated_list>
        </section>
    </section>
</document>
