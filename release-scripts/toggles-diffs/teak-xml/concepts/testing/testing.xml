<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/openedx/edx-platform/docs/concepts/testing/testing.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="testing" names="testing">
        <title>Testing</title>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id2" refid="overview">Overview</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id3" refid="test-types">Test Types</reference></paragraph>
                            <bullet_list>
                                <list_item>
                                    <paragraph><reference ids="id4" refid="unit-tests">Unit Tests</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id5" refid="integration-tests">Integration Tests</reference></paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id6" refid="test-locations">Test Locations</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id7" refid="factories">Factories</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id8" refid="running-python-unit-tests">Running Python Unit tests</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id9" refid="running-python-test-subsets">Running Python Test Subsets</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id10" refid="testing-with-migrations">Testing with migrations</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id11" refid="debugging-a-test">Debugging a test</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id12" refid="how-to-output-coverage-locally">How to output coverage locally</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id13" refid="handling-flaky-unit-tests">Handling flaky unit tests</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id14" refid="running-javascript-unit-tests">Running JavaScript Unit Tests</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id15" refid="code-quality">Code Quality</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="overview" names="overview">
            <title refid="id2">Overview</title>
            <paragraph>We maintain two kinds of tests: unit tests and integration tests.</paragraph>
            <paragraph>Overall, you want to write the tests that <strong>maximize coverage</strong> while
                <strong>minimizing maintenance</strong>. In practice, this usually means investing
                heavily in unit tests, which tend to be the most robust to changes in
                the code base.</paragraph>
            <figure ids="id1">
                <image alt="Test Pyramid" candidates="{'*': 'concepts/testing/test_pyramid.png'}" original_uri="test_pyramid.png" uri="concepts/testing/test_pyramid.png"></image>
                <caption>Test Pyramid</caption>
            </figure>
            <paragraph>The pyramid above shows the relative number of unit tests and integration
                tests. Most of our tests are unit tests or
                integration tests.</paragraph>
            <section ids="test-types" names="test\ types">
                <title refid="id3">Test Types</title>
                <section ids="unit-tests" names="unit\ tests">
                    <title refid="id4">Unit Tests</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Each test case should be concise: setup, execute, check, and
                                teardown. If you find yourself writing tests with many steps,
                                consider refactoring the unit under tests into smaller units, and
                                then testing those individually.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>As a rule of thumb, your unit tests should cover every code branch.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Mock or patch external dependencies using <reference name="unittest.mock" refuri="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</reference> functions.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>We unit test Python code (using <reference name="unittest" refuri="http://docs.python.org/2/library/unittest.html">unittest</reference>) and Javascript (using
                                <reference name="Jasmine" refuri="http://jasmine.github.io/">Jasmine</reference>)</paragraph>
                        </list_item>
                    </bullet_list>
                    <target ids="unittest-mock" names="unittest.mock" refuri="https://docs.python.org/3/library/unittest.mock.html"></target>
                    <target ids="unittest" names="unittest" refuri="http://docs.python.org/2/library/unittest.html"></target>
                    <target ids="jasmine" names="jasmine" refuri="http://jasmine.github.io/"></target>
                </section>
                <section ids="integration-tests" names="integration\ tests">
                    <title refid="id5">Integration Tests</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Test several units at the same time. Note that you can still mock or patch
                                dependencies that are not under test! For example, you might test that
                                <literal>LoncapaProblem</literal>, <literal>NumericalResponse</literal>, and <literal>CorrectMap</literal> in the <literal>capa</literal>
                                package work together, while still mocking out template rendering.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Use integration tests to ensure that units are hooked up correctly.  You do
                                not need to test every possible input–that’s what unit tests are for.
                                Instead, focus on testing the “happy path” to verify that the components work
                                together correctly.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Many of our tests use the <reference name="Django test client" refuri="https://docs.djangoproject.com/en/dev/topics/testing/overview/">Django test client</reference> to simulate HTTP requests to
                                the server.</paragraph>
                        </list_item>
                    </bullet_list>
                    <target ids="django-test-client" names="django\ test\ client" refuri="https://docs.djangoproject.com/en/dev/topics/testing/overview/"></target>
                </section>
            </section>
            <section ids="test-locations" names="test\ locations">
                <title refid="id6">Test Locations</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Python unit and integration tests: Located in subpackages called
                            <literal>tests</literal>. For example, the tests for the <literal>capa</literal> package are
                            located in <literal>xmodule/capa/tests</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Javascript unit tests: Located in <literal>spec</literal> folders. For example,
                            <literal>xmodule/js/spec</literal> and
                            <literal>{cms,lms}/static/js/spec</literal> For consistency, you should use the
                            same directory structure for implementation and test. For example,
                            the test for <literal>src/views/module.js</literal> should be written in
                            <literal>spec/views/module_spec.js</literal>.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="factories" names="factories">
                <title refid="id7">Factories</title>
                <paragraph>Many tests delegate set-up to a “factory” class. For example, there are
                    factories for creating courses, problems, and users. This encapsulates
                    set-up logic from tests.</paragraph>
                <paragraph>Factories are often implemented using <reference name="FactoryBoy" refuri="https://readthedocs.org/projects/factoryboy/">FactoryBoy</reference>.</paragraph>
                <paragraph>In general, factories should be located close to the code they use. For
                    example, the factory for creating problem XML definitions is located in
                    <literal>xmodule/capa/tests/response_xml_factory.py</literal> because the
                    <literal>capa</literal> package handles problem XML.</paragraph>
                <target ids="factoryboy" names="factoryboy" refuri="https://readthedocs.org/projects/factoryboy/"></target>
            </section>
        </section>
        <section ids="running-python-unit-tests" names="running\ python\ unit\ tests">
            <title refid="id8">Running Python Unit tests</title>
            <paragraph>The following commands need to be run within a Python environment in
                which requirements/edx/testing.txt has been installed. If you are using a
                Docker-based Open edX distribution, then you probably will want to run these
                commands within the LMS and/or CMS Docker containers.</paragraph>
            <paragraph>We use <reference name="pytest" refuri="https://pytest.org/">pytest</reference> to run Python tests. Pytest is a testing framework for python and should be your goto for local Python unit testing.</paragraph>
            <paragraph>Pytest (and all of the plugins we use with it) has a lot of options. Use <title_reference>pytest –help</title_reference> to see all your option and pytest has good docs around testing.</paragraph>
            <target ids="pytest" names="pytest" refuri="https://pytest.org/"></target>
            <section ids="running-python-test-subsets" names="running\ python\ test\ subsets">
                <title refid="id9">Running Python Test Subsets</title>
                <paragraph>When developing tests, it is often helpful to be able to really just run one single test without the overhead of PIP installs, UX builds, etc.</paragraph>
                <paragraph>Various ways to run tests using pytest:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest path/test_module.py                          # Run all tests in a module.
pytest path/test_module.py::test_func               # Run a specific test within a module.
pytest path/test_module.py::TestClass               # Run all tests in a class
pytest path/test_module.py::TestClass::test_method  # Run a specific method of a class.
pytest path/testing/                                # Run all tests in a directory.</literal_block>
                <paragraph>For example, this command runs a single python unit test file:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest xmodule/tests/test_stringify.py</literal_block>
                <paragraph>Note -
                    edx-platorm has multiple services (lms, cms) in it. The environment for each service is different enough that we run some tests in both environments in Github Actions.
                    To test in each of these environments (especially for tests in “common” and “xmodule” directories), you will need to test in each seperately.
                    To specify that the tests are run with the relevant service as root, Add –rootdir flag at end of your pytest call and specify the env to test in:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest test --rootdir &lt;lms or cms&gt;</literal_block>
                <paragraph>Or, if you need django settings from a particular enviroment, add –ds flag to the end of your pytest call and specify the django settings object:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest test --ds=&lt;lms.envs.test or cms.envs.test&gt;</literal_block>
                <paragraph>Various tools like ddt create tests with very complex names, rather than figuring out the name yourself, you can:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Select tests to run based on their name, provide an expression to the <reference name="pytest -k option" refuri="https://docs.pytest.org/en/latest/example/markers.html#using-k-expr-to-select-tests-based-on-their-name">pytest -k option</reference> which performs a substring match on test names:</paragraph>
                        <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest xmodule/tests/test_stringify.py -k test_stringify</literal_block>
                    </list_item>
                </enumerated_list>
                <target ids="pytest-k-option" names="pytest\ -k\ option" refuri="https://docs.pytest.org/en/latest/example/markers.html#using-k-expr-to-select-tests-based-on-their-name"></target>
                <target ids="node-id" names="node\ id" refuri="https://docs.pytest.org/en/latest/example/markers.html#node-id"></target>
                <enumerated_list enumtype="arabic" prefix="" start="2" suffix=".">
                    <list_item>
                        <paragraph>Alternatively, you can the get the name of all test methods in a class, file, or project, including all ddt.data variations, by running pytest with <title_reference>–collectonly</title_reference>:</paragraph>
                        <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest xmodule/tests/test_stringify.py --collectonly</literal_block>
                    </list_item>
                </enumerated_list>
            </section>
            <section ids="testing-with-migrations" names="testing\ with\ migrations">
                <title refid="id10">Testing with migrations</title>
                <paragraph>For the sake of speed, by default the python unit test database tables
                    are created directly from apps’ models. If you want to run the tests
                    against a database created by applying the migrations instead, use the
                    <literal>--create-db --migrations</literal> option:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest test --create-db --migrations</literal_block>
            </section>
            <section ids="debugging-a-test" names="debugging\ a\ test">
                <title refid="id11">Debugging a test</title>
                <paragraph>There are various ways to debug tests in Python and more specifically with pytest:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>using the verbose -v or really verbose -vv flags can be helpful for displaying diffs on assertion failures</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>if you want to focus on one test failure at a time, the <literal>--exitfirst``or ``-x</literal> flags to have pytest stop after the first failure</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>by default, the plugin pytest-randomly will randomize test case sequence. This is to help reveal bugs in your test setup and teardown. If you do not want this randomness, use the –randomly-dont-reorganize flag</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>if you pass the <literal>--pdb</literal> flag to a pytest call, the test runner will drop you into pdb on error. This lets you go up and down the stack and see what the values of the variables are. Check out <reference name="the pdb documentation" refuri="http://docs.python.org/library/pdb.html">the pdb documentation</reference>.  Note that this only works if you aren’t collecting coverage statistics (pdb and coverage.py use the same mechanism to trace code execution).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If there is a specific point in code you would like to debug, you can add the build-in “breakpoint()” function there and it will automatically drop you at the point next time the code runs. If you check this in, your tests will hang on jenkins. Example of use:</paragraph>
                        <literal_block force="False" language="default" linenos="False" xml:space="preserve">if True:
  # you will be dropped here in the pdb shell when running test or code
  breakpoint()
  a=2
  random_variable = False</literal_block>
                    </list_item>
                </bullet_list>
                <target ids="the-pdb-documentation" names="the\ pdb\ documentation" refuri="http://docs.python.org/library/pdb.html"></target>
            </section>
            <section ids="how-to-output-coverage-locally" names="how\ to\ output\ coverage\ locally">
                <title refid="id12">How to output coverage locally</title>
                <paragraph>These are examples of how to run a single test and get coverage:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest cms/djangoapps/contentstore/tests/test_import.py --cov --cov-config=.coveragerc-local # cms example
pytest lms/djangoapps/courseware/tests/test_block_render.py --cov --cov-config=.coveragerc-local # lms example</literal_block>
                <paragraph>That <literal>--cov-conifg=.coveragerc-local</literal> option is important - without it, the coverage
                    tool will look for paths that exist on our jenkins test servers, but not on your local devstack.</paragraph>
                <paragraph>How to spit out coverage for a single file with a list of each line that is missing coverage:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">pytest lms/djangoapps/grades/tests/test_subsection_grade.py \
    --cov=lms.djangoapps.grades.subsection_grade \
    --cov-config=.coveragerc-local \
    --cov-report=term-missing
---------- coverage: platform linux2, python 2.7.12-final-0 ----------

Name                                        Stmts   Miss  Cover   Missing
-------------------------------------------------------------------------
lms/djangoapps/grades/subsection_grade.py     125     38    70%   47-51, 57, 80-81, 85, 89, 99, 109, 113, [...]</literal_block>
                <paragraph>Use this command to generate a coverage report (after previously running <literal>pytest</literal>):</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">coverage report</literal_block>
                <paragraph>The above command looks for a test coverage data file in <literal>reports/.coverage</literal> - this file will
                    contain coverage data from your last run of <literal>pytest</literal>.  Coverage data is recorded for whichever
                    paths you specified in your <literal>--cov</literal> option, e.g.:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">--cov=.  # will track coverage for the entire project
--cov=path.to.your.module  # will track coverage only for "module"</literal_block>
                <paragraph>Use this command to generate an HTML report:</paragraph>
                <literal_block force="False" language="default" linenos="False" xml:space="preserve">coverage html</literal_block>
                <paragraph>The report is then saved in reports/xmodule/cover/index.html</paragraph>
            </section>
            <section ids="handling-flaky-unit-tests" names="handling\ flaky\ unit\ tests">
                <title refid="id13">Handling flaky unit tests</title>
                <paragraph>See this <reference name="confluence document" refuri="https://openedx.atlassian.net/wiki/spaces/AC/pages/4306337795/Flaky+Test+Process">confluence document</reference><target ids="confluence-document" names="confluence\ document" refuri="https://openedx.atlassian.net/wiki/spaces/AC/pages/4306337795/Flaky+Test+Process"></target>.</paragraph>
            </section>
        </section>
        <section ids="running-javascript-unit-tests" names="running\ javascript\ unit\ tests">
            <title refid="id14">Running JavaScript Unit Tests</title>
            <paragraph>Before running Javascript unit tests, you will need to be running Firefox or Chrome in a place visible to edx-platform.
                If you are using Tutor Dev to run edx-platform, then you can do so by installing and enabling the
                <literal>test-legacy-js</literal> plugin from <reference name="openedx-tutor-plugins" refuri="https://github.com/openedx/openedx-tutor-plugins/">openedx-tutor-plugins</reference>, and then rebuilding
                the <literal>openedx-dev</literal> image:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">tutor plugins install https://github.com/openedx/openedx-tutor-plugins/tree/main/plugins/tutor-contrib-test-legacy-js
tutor plugins enable test-legacy-js
tutor images build openedx-dev</literal_block>
            <target ids="openedx-tutor-plugins" names="openedx-tutor-plugins" refuri="https://github.com/openedx/openedx-tutor-plugins/"></target>
            <paragraph>We use Jasmine (via Karma) to run most JavaScript unit tests. We use Jest to
                run a small handful of additional JS unit tests. You can use the <literal>npm run
test*</literal> commands to run them:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">npm run test-karma  # Run all Jasmine+Karma tests.
npm run test-jest   # Run all Jest tests.
npm run test        # Run both of the above.</literal_block>
            <paragraph>The Karma tests are further broken down into three types depending on how the
                JavaScript it is testing is built:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">npm run test-karma-vanilla  # Our very oldest JS, which doesn't even use RequireJS
npm run test-karma-require  # Old JS that uses RequireJS
npm run test-karma-webpack  # Slightly "newer" JS which is built with Webpack</literal_block>
            <paragraph>Unfortunately, at the time of writing, the build for the <literal>test-karma-webpack</literal>
                tests is broken. The tests are excluded from <literal>npm run test-karma</literal> as to not
                fail CI. We <reference name="may fix this one day" refuri="https://github.com/openedx/edx-platform/issues/35956">may fix this one day</reference>.</paragraph>
            <target ids="may-fix-this-one-day" names="may\ fix\ this\ one\ day" refuri="https://github.com/openedx/edx-platform/issues/35956"></target>
            <paragraph>To run all Karma+Jasmine tests for a particular top-level edx-platform folder,
                you can run:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">npm run test-cms
npm run test-lms
npm run test-xmodule
npm run test-common</literal_block>
            <paragraph>Finally, if you want to pass any options to the underlying <literal>node</literal> invocation
                for Karma+Jasmine tests, you can run one of these specific commands, and put
                your arguments after the <literal>--</literal> separator:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">npm run test-cms-vanilla -- --your --args --here
npm run test-cms-require -- --your --args --here
npm run test-cms-webpack -- --your --args --here
npm run test-lms-webpack -- --your --args --here
npm run test-xmodule-vanilla -- --your --args --here
npm run test-xmodule-webpack -- --your --args --here
npm run test-common-vanilla -- --your --args --here
npm run test-common-require -- --your --args --here</literal_block>
        </section>
        <section ids="code-quality" names="code\ quality">
            <title refid="id15">Code Quality</title>
            <paragraph>We use several tools to analyze code quality. The full set of them is:</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">mypy $PATHS...
pycodestyle $PATHS...
pylint $PATHS...
lint-imports
scripts/verify-dunder-init.sh
make xsslint
make pii_check
make check_keywords</literal_block>
            <paragraph>Where <literal>$PATHS...</literal> is a list of folders and files to analyze, or nothing if
                you would like to analyze the entire codebase (which can take a while).</paragraph>
        </section>
    </section>
</document>
