<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/openedx/edx-platform/docs/references/docs/openedx/core/djangoapps/course_apps/docs/decisions/001-course-apps.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="course-apps-api" names="course\ apps\ api">
        <title>Course Apps API</title>
        <section ids="status" names="status">
            <title>Status</title>
            <paragraph>Proposal</paragraph>
        </section>
        <section ids="context" names="context">
            <title>Context</title>
            <paragraph>The new <reference name="Course Authoring MFE" refuri="https://github.com/openedx/frontend-app-course-authoring/">Course Authoring MFE</reference> includes a new UX called “Pages and Resources”
                for configuring different aspects of the course experience such as progress,
                wiki, teams, discussions, etc. all from one place.</paragraph>
            <paragraph>Currently, the code for these aspects of the course experience is intermingled
                with the core platform, however, it would be useful to have a way to
                automatically discover the data for driving this page instead of hardcoding it
                such that in the future existing functionality can be split out into an external
                plugin and so that future third-party plugins can also show up here.</paragraph>
            <paragraph>This ADR describes how we can use the existing plugin architecture of Open edX
                to automatically discover such apps and expose them via an API. This API will
                be used to list the installed apps that are available for a course and to
                enable/disable these apps using the API.</paragraph>
            <target ids="course-authoring-mfe" names="course\ authoring\ mfe" refuri="https://github.com/openedx/frontend-app-course-authoring/"></target>
        </section>
    </section>
    <section ids="decision" names="decision">
        <title>Decision</title>
        <paragraph>We propose to call such individual course features “Course Apps”. They can be
            introduced as a new type of Open edX plugin. Any functionality that can be
            enabled or disabled at a course-level and can be configured by instructors is
            a candidate for being bundled as a Course App.</paragraph>
        <paragraph>To be able to show these Course Apps to course admins, they will need to provide
            some bits of metadata, such as a name, a description etc. Additionally we will
            need a common interface for such apps so they can be enabled/disabled using
            a standard common interface.</paragraph>
        <paragraph>To do this we can follow the example of existing plugins, <reference name="such as Course Tabs" refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/common/lib/xmodule/xmodule/tabs.py#L24-L243">such as Course Tabs</reference>,
            which provide a specific Python class that the plugin can inherit from, or
            implement. The required metadata and features, can be implemented as class
            attributes, and methods on this class.</paragraph>
        <paragraph>We can then discover the installed apps using the existing tooling for plugins
            using a subclass of <literal>PluginManager</literal> designed for this purpose.
            Here is an example for <reference name="CourseTabs" refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/openedx/core/lib/course_tabs.py#L13-L47">CourseTabs</reference>:</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">class CourseTabPluginManager(PluginManager):
"""
Manager for all of the course tabs that have been made available.

All course tabs should implement `CourseTab`.
"""
NAMESPACE = COURSE_TAB_NAMESPACE

@classmethod
def get_tab_types(cls):
    """
    Returns the list of available course tabs in their canonical order.</literal_block>
        <paragraph>It might not always make sense for an app installed in this way to be
            automatically show up for use on all courses. So each app will expose a method
            to check if it should be available for a particular course.</paragraph>
        <paragraph>Once an app has been marked as available for a course, it will show up in the
            API, where the next step is to mark it as enabled.</paragraph>
        <paragraph>In the context of these apps, we need to distinguish between <emphasis>installed</emphasis>,
            <emphasis>available</emphasis> and <emphasis>enabled</emphasis>.</paragraph>
        <paragraph>Let’s look at an existing feature to explain those terms. The <title_reference>edxnotes</title_reference> app
            has [code that is part of the
            platform](<reference refuri="https://github.com/openedx/edx-platform/tree/636b2ca4c5add531cfce755fdb8965599acd79e0/lms/djangoapps/edxnotes">https://github.com/openedx/edx-platform/tree/636b2ca4c5add531cfce755fdb8965599acd79e0/lms/djangoapps/edxnotes</reference>).
            This code comes preinstalled since it’s part of the platform. So it is already
            <emphasis>installed</emphasis>, however no one can use it just yet, since it it needs to first be
            enabled globally. In the case of an external plugin, you consider it installed
            if it is <problematic ids="id2" refid="id1">`</problematic>pip install`ed in the same environment in which edx-platform is
            running.</paragraph>
        <paragraph>To make the feature <emphasis>available</emphasis> for use, you need to now [enable a feature
            flag](<reference refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/lms/envs/common.py#L531-L543">https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/lms/envs/common.py#L531-L543</reference>).
            Until this is set course authors/admins will [not even see the option of
            enabling this for their
            course](<reference refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/cms/djangoapps/models/settings/course_metadata.py#L91-L93">https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/cms/djangoapps/models/settings/course_metadata.py#L91-L93</reference>).
            For course apps this is where the availability check comes in.</paragraph>
        <paragraph>In the case of <title_reference>edxnotes</title_reference>, after setting the above feature flag, an option will
            show up in the advanced settings page of studio that allows you to <emphasis>enable</emphasis>
            the <title_reference>edxnotes</title_reference> for a particular course. If this value is true, then edxnotes
            will be enabled for the course.</paragraph>
        <paragraph>In the case of Course Apps, the standard plugin API will automatically discover
            all installed apps. Inactive apps will be filtered out during the availability
            check.</paragraph>
        <target ids="such-as-course-tabs" names="such\ as\ course\ tabs" refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/common/lib/xmodule/xmodule/tabs.py#L24-L243"></target>
        <target ids="coursetabs" names="coursetabs" refuri="https://github.com/openedx/edx-platform/blob/636b2ca4c5add531cfce755fdb8965599acd79e0/openedx/core/lib/course_tabs.py#L13-L47"></target>
        <paragraph>To be loaded as a Course App, you need to provide an entrypoint in <literal>setup.py</literal>
            with the namespace <literal>openedx.course_app</literal>. The entry should point to a Python
            class with the following basic structure:</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">class CourseApp:
    # The app id should match what is specified in the setup.py entrypoint
    app_id: str = 'wiki'
    name: str = 'Wiki'
    description: str = 'A short description of what the Wiki does.'
    # Specify if this app is enabled by default. If the app is made available for a course
    # should it also automatically be considered enabled.
    default_enabled: bool = False

    # This method will not be in the sample/base class, but will be added to
    # existing Course Apps.
    if LEGACY_APP:
        @classmethod
        def legacy_link(cls, course_key):
            return f'some/link/to/{course_key}'

    @classmethod
    def is_available(cls, course_key):
        # Some mechanism, ideally a waffle flag in the Course Apps namespace
        # to see if this app can be enabled/configured for this course.
        return True

    @classmethod
    def is_enabled(cls, course_key):
        # Some logic to check if the app is enabled for this course
        # This will not vary from user-to-user in studio.
        return True

    @classmethod
    def set_enabled(cls, course_key, user, enabled):
        # Some logic to enable the app for this course.
        # The user here isn't passed on for permission checking, but just
        # for logging/auditing.
        return enabled

    @classmethod
    def get_allowed_operations(cls, course_key, user):
        # This should return a dictionary with at least the `enable` and `configure` keys.
        return {
            'enable': can_user_enable(course_key, user),
            'configure': can_user_configure(course_key, user),
        }</literal_block>
        <paragraph>For existing features that need to be exposed as Course Apps, we can create
            such a class and have these class methods call back to the existing code for
            availability checks and enabled checks.</paragraph>
        <paragraph>Each app has some associated metadata:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><strong>id</strong>: (string) A unique identifier for the app.</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>name</strong>: (string) A friendly name for the app that can be shown in the UI.</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>description</strong>: (string) A friendly description of what the app does, to be shown to
                    users in the UI.</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>enabled</strong>: (boolean) Is this app enabled for the current course.</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>allowed_operations</strong>: (dictionary) Apps can potentially enable/disable certain
                    operations. The following operations should be specified for all apps:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>enable</strong>: (boolean) Can the current user enable/disable this app.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>configure</strong>: (boolean) Can the current user can configure this app.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>If an app doesn’t have any configuration it can set the <literal>configure</literal> to false
                    and the UI will simply not show a configuration option for that app.</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>legacy_link</strong>: (string) If available, this will point to the legacy link for
                    configuring the app. This can be provided as a fallback while the new UX is
                    still in development.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>The is also the structure that will form the basis of the API’s response:</paragraph>
        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">{
    'id': 'courseapp',
    'enabled': False,
    'name': 'Course App',
    'description': 'A sample Course App for use as documentation.',
    'allowed_operations': {
        'enable': True,
        'configure': True,
        'edit_lti_config': False,
    },
    'legacy_link': 'https://studio.example.com/course_id/app-page',
}</literal_block>
        <paragraph>This API can be hosted at: <literal>/course_apps/v1/apps/{course_id}/</literal></paragraph>
        <block_quote>
            <paragraph>GET <literal>/course_apps/v1/apps/{course_id}/</literal></paragraph>
        </block_quote>
        <paragraph>A <literal>GET</literal> request to this API will return an array of objects with the above
            structure.</paragraph>
        <block_quote>
            <definition_list>
                <definition_list_item>
                    <term>PATCH <literal>/course_apps/v1/apps/{course_id}/</literal> {</term>
                    <definition>
                        <paragraph>“id”: “wiki”,
                            “enabled”: true</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>}</paragraph>
        </block_quote>
        <paragraph>A <literal>PATCH</literal> request to the same endpoint with just the <literal>id</literal> of the application
            and the <literal>enabled</literal> attribute can be used to enable/disable the app if it’s
            possible to do so.</paragraph>
        <paragraph>Note that it may not always be possible to enable/disable an app. Similar to
            disabling an XBlock from a course that’s in use, some apps might break the
            course if you remove them while they are in use. In other cases the app may not
            support enabling/disabling without changing a setting/django config. Or an app
            might need to be configured first before it can be enabled.</paragraph>
        <paragraph>This data is provided by the a special configuration class that is part of the app.
            It’s structure is detailed in the previous section.</paragraph>
        <paragraph>To enumerate the list of available apps, we will list the installed plugins,
            check which plugins are available for the current course using <title_reference>is_available</title_reference>
            and get the static metadata from the config class. If the plugin marks itself
            as unavailable, it won’t be listed in the API response.</paragraph>
        <paragraph>Only legacy apps will support the <literal>legacy_link</literal> method, it will not be a
            publicised part of the API so new/external plugin apps shouldn’t use it. This
            link should only be provided for Course Apps that don’t have a UI in the course
            authoring MFE yet. If a partial UI exists, the MFE settings view can always link
            back to the old studio view from there.</paragraph>
        <section ids="consequences" names="consequences">
            <title>Consequences</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A new Course Apps API that consistently uses a standard mechanism (a plugin
                        class) for discovering Course Apps, determining their availability and
                        enabling/disabling them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>We still leave the more complex considerations of configuration to each
                        individual app to implement in its own best way. i.e. the aim here isn’t to
                        have a uniform API to configure all Course Apps.</paragraph>
                </list_item>
            </bullet_list>
        </section>
    </section>
</document>
