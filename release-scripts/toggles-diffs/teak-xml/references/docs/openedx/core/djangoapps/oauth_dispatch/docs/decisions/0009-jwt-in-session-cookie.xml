<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/openedx/edx-platform/docs/references/docs/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0009-jwt-in-session-cookie.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="transport-jwt-in-http-cookies" names="9.\ transport\ jwt\ in\ http\ cookies">
        <title>9. Transport JWT in HTTP Cookies</title>
    </section>
    <section ids="status" names="status">
        <title>Status</title>
        <paragraph>Accepted</paragraph>
    </section>
    <section ids="context" names="context">
        <title>Context</title>
        <paragraph>For background, please see:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph><reference name="Use JWT as OAuth2 Tokens" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0003-use-jwt-as-oauth-tokens-remove-openid-connect.rst">Use JWT as OAuth2 Tokens</reference>, where we decided to use JSON Web Tokens (JWTs) as OAuth2 access tokens, thereby
                    embedding user identification information in access tokens.</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference name="Use Asymmetric JWTs" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0008-use-asymmetric-jwts.rst">Use Asymmetric JWTs</reference>, where we decided to sign JWTs with public-private keypairs, thereby enabling less trusted
                    3rd parties to receive and verify JWTs (with published signing public keys).</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>These earlier decisions have focused on the authentication needs of backend services for their connections and API
            requests. Those services use traditional OAuth2 grant types (Credentials and Authorization Code) and obtain JWTs for
            making API requests - as described in <reference name="Use JWT as OAuth2 Tokens" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0003-use-jwt-as-oauth-tokens-remove-openid-connect.rst">Use JWT as OAuth2 Tokens</reference>.</paragraph>
        <paragraph>Moving forward, we need a simple and easy-to-use authentication mechanism for frontend applications as well. As
            described in <reference name="Decoupled Frontend Architecture" refuri="https://openedx.atlassian.net/wiki/spaces/FEDX/pages/790692200/Decoupled+Frontend+Architecture">Decoupled Frontend Architecture</reference>, each individual <reference name="microfrontend" refuri="https://micro-frontends.org/">microfrontend</reference> supports its own use case. As a
            user interacts with the overall application, the user’s experience may lead them through multiple microfrontends,
            each accessing APIs on various backends. Stateless authentication (via self-contained JWTs) would allow scalable
            interactions between microfrontends and microservices.</paragraph>
        <paragraph>Note: User authentication for Open edX mobile apps is outside the scope of this decision record. As a brief note, we
            believe any decisions in this record will neither affect the current authentication mechanisms used for mobile
            apps nor impact forward compatibility when/if mobile apps are consolidated to use a similar (if not the same)
            authentication mechanism as outlined here for web apps.</paragraph>
        <target ids="use-jwt-as-oauth2-tokens" names="use\ jwt\ as\ oauth2\ tokens" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0003-use-jwt-as-oauth-tokens-remove-openid-connect.rst"></target>
        <target ids="use-asymmetric-jwts" names="use\ asymmetric\ jwts" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0008-use-asymmetric-jwts.rst"></target>
        <target ids="decoupled-frontend-architecture" names="decoupled\ frontend\ architecture" refuri="https://openedx.atlassian.net/wiki/spaces/FEDX/pages/790692200/Decoupled+Frontend+Architecture"></target>
        <target ids="microfrontend" names="microfrontend" refuri="https://micro-frontends.org/"></target>
    </section>
    <section ids="decisions" names="decisions">
        <title>Decisions</title>
        <section ids="login-cookie-api" names="login\ -&gt;\ cookie\ -&gt;\ api">
            <title>Login -&gt; Cookie -&gt; API</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Single Login Microfrontend and Microservice.</strong> There will be only a single microfrontend and a corresponding
                        single (backend) microservice (currently LMS) from which users can login to the edX system. This will isolate any
                        login-related vulnerabilities (i.e., frontend applications that gain access to users’ passwords) and
                        login-related protections (i.e., password validation policies) to single points in the system.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>“Two JWT Cookies”.</strong> Upon successful login, the backend login service will create and sign a JWT to identify the
                        newly logged in user. The JWT will be divided into the following 2 HTTP cookies (inspired by <reference name="Lightrail's design" refuri="https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3">Lightrail’s
                            design</reference>), included in the login response, and stored in the user’s browser cookie jar:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph><strong>“JWT Header/Payload Cookie”</strong></paragraph>
                            <bullet_list bullet="*">
                                <list_item>
                                    <paragraph>Contains only the header and payload portions of the JWT.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Disable <reference name="HTTPOnly" refuri="https://www.owasp.org/index.php/HttpOnly">HTTPOnly</reference> so the microfrontend can access user/role data in the JWT payload.</paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                        <list_item>
                            <paragraph><strong>“JWT Signature Cookie”</strong></paragraph>
                            <bullet_list bullet="*">
                                <list_item>
                                    <paragraph>Contains only the public key signature portion of the JWT.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Enable <reference name="HTTPOnly" refuri="https://www.owasp.org/index.php/HttpOnly">HTTPOnly</reference> so the signature is unavailable to JS code. See <reference name="JWT Cookie Security" refid="jwt-cookie-security">JWT Cookie Security</reference> below.</paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>Automatically recombine and extract the JWT from Cookies on API calls.</strong></paragraph>
                    <block_quote>
                        <bullet_list bullet="*">
                            <list_item>
                                <paragraph>A new middleware JwtAuthCookieMiddleware will reconstitute the divided JWT from its two cookies and store the
                                    recombined JWT in a temporary cookie specified by <reference name="JWT_AUTH_COOKIE" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/master/docs/index.md#jwt_auth_cookie">JWT_AUTH_COOKIE</reference>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>The <reference name="Django Rest Framework JWT" refuri="https://getblimp.github.io/django-rest-framework-jwt/">Django Rest Framework JWT</reference> library we use makes use of the <reference name="JWT_AUTH_COOKIE" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/master/docs/index.md#jwt_auth_cookie">JWT_AUTH_COOKIE</reference> configuration setting.
                                    When set, the <reference name="JSONWebTokenAuthentication" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/0a0bd402ec21fd6b9a5f715d114411836fbb2923/rest_framework_jwt/authentication.py#L71">JSONWebTokenAuthentication</reference> class <reference name="automatically extracts the JWT from the cookie" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/0a0bd402ec21fd6b9a5f715d114411836fbb2923/rest_framework_jwt/authentication.py#L86-L87">automatically extracts the JWT from the cookie</reference>. Since all
                                    Open edX REST endpoints that support JWT-based authentication derive from this base class, their authentication
                                    checks will make use of the JWTs provided in the JWT-related cookies.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Introduce forgiving JWTs for backward compatibility.</strong></paragraph>
                    <block_quote>
                        <bullet_list bullet="*">
                            <list_item>
                                <paragraph><strong>Update</strong>: As of Nov-2023, the title of this section has been updated from its original: “Introduce
                                    HTTP_USE_JWT_COOKIE header for backward compatibility and rollout.” The purpose of this old header has not
                                    changed, but the implementation has changed to a concept which can be read about “forgiving JWTs” in this
                                    <reference name="Replace USE-JWT-COOKIE ADR" refuri="https://github.com/openedx/edx-drf-extensions/blob/master/docs/decisions/0002-remove-use-jwt-cookie-header.rst">Replace USE-JWT-COOKIE ADR</reference>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>As we incrementally add JWTAuthentication throughout all backend microservices and APIs, we will need to support
                                    multiple authentication mechanisms for a period of time. Once JWT cookies are enabled and automatically sent with
                                    every (post-Login) AJAX request from the browser, backend APIs will try to authenticate the request with the
                                    sent JWT cookies.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>The cookies are sent regardless of whether the request comes from an updated microfrontend or from a legacy
                                    server-side rendered UI. However, since only updated microfrontends will have the logic to refresh JWT cookies
                                    (see “Refresh JWT Cookies” below), older frontends will not handle expired JWT cookies and so will run into 401
                                    failures.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>To prevent this issue, we will introduce a new HTTP header called “HTTP_USE_JWT_COOKIE” that will be selectively
                                    set only by microfrontends that want to use JWT cookie based authentication. The new middleware will check for
                                    this header before trying to reconstitute and use the JWT token.</paragraph>
                                <block_quote>
                                    <bullet_list bullet="*">
                                        <list_item>
                                            <paragraph><strong>Update</strong>: As of Nov-2023, “forgiving JWTs” is the replacement implementation that can be read about in
                                                the <reference name="Replace USE-JWT-COOKIE ADR" refuri="https://github.com/openedx/edx-drf-extensions/blob/master/docs/decisions/0002-remove-use-jwt-cookie-header.rst">Replace USE-JWT-COOKIE ADR</reference>.</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>Additionally, select login-required APIs can be updated to redirect the caller to the Login page when the JWT
                                    expires. This can be accomplished by enabling <reference name="JwtRedirectToLoginIfUnauthenticatedMiddleware" refuri="https://github.com/openedx/edx-drf-extensions/blob/0351010f1836e4cebd6bdc757d477b2f56265b17/edx_rest_framework_extensions/auth/jwt/middleware.py#L76">JwtRedirectToLoginIfUnauthenticatedMiddleware</reference> in the Django
                                    service and updating the API to require the <reference name="LoginRedirectIfUnauthenticated" refuri="https://github.com/openedx/edx-drf-extensions/blob/0351010f1836e4cebd6bdc757d477b2f56265b17/edx_rest_framework_extensions/permissions.py#L147">LoginRedirectIfUnauthenticated</reference> permission class. The middleware
                                    automatically sets “HTTP_USE_JWT_COOKIE” for incoming requests to APIs that require the
                                    <reference name="LoginRedirectIfUnauthenticated" refuri="https://github.com/openedx/edx-drf-extensions/blob/0351010f1836e4cebd6bdc757d477b2f56265b17/edx_rest_framework_extensions/permissions.py#L147">LoginRedirectIfUnauthenticated</reference> permission.</paragraph>
                                <bullet_list bullet="*">
                                    <list_item>
                                        <paragraph><strong>Update</strong>: As of Nov-2023, the middleware no longer needs to set this header, as can be read about in the
                                            <reference name="Replace USE-JWT-COOKIE ADR" refuri="https://github.com/openedx/edx-drf-extensions/blob/master/docs/decisions/0002-remove-use-jwt-cookie-header.rst">Replace USE-JWT-COOKIE ADR</reference>.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </enumerated_list>
            <target ids="lightrail-s-design" names="lightrail's\ design" refuri="https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3"></target>
            <target ids="django-rest-framework-jwt" names="django\ rest\ framework\ jwt" refuri="https://getblimp.github.io/django-rest-framework-jwt/"></target>
            <target ids="jwt-auth-cookie" names="jwt_auth_cookie" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/master/docs/index.md#jwt_auth_cookie"></target>
            <target ids="jsonwebtokenauthentication" names="jsonwebtokenauthentication" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/0a0bd402ec21fd6b9a5f715d114411836fbb2923/rest_framework_jwt/authentication.py#L71"></target>
            <target ids="automatically-extracts-the-jwt-from-the-cookie" names="automatically\ extracts\ the\ jwt\ from\ the\ cookie" refuri="https://github.com/GetBlimp/django-rest-framework-jwt/blob/0a0bd402ec21fd6b9a5f715d114411836fbb2923/rest_framework_jwt/authentication.py#L86-L87"></target>
            <target ids="replace-use-jwt-cookie-adr" names="replace\ use-jwt-cookie\ adr" refuri="https://github.com/openedx/edx-drf-extensions/blob/master/docs/decisions/0002-remove-use-jwt-cookie-header.rst"></target>
            <target ids="jwtredirecttologinifunauthenticatedmiddleware" names="jwtredirecttologinifunauthenticatedmiddleware" refuri="https://github.com/openedx/edx-drf-extensions/blob/0351010f1836e4cebd6bdc757d477b2f56265b17/edx_rest_framework_extensions/auth/jwt/middleware.py#L76"></target>
            <target ids="loginredirectifunauthenticated" names="loginredirectifunauthenticated" refuri="https://github.com/openedx/edx-drf-extensions/blob/0351010f1836e4cebd6bdc757d477b2f56265b17/edx_rest_framework_extensions/permissions.py#L147"></target>
        </section>
        <section ids="jwt-cookie-lifetime" names="jwt\ cookie\ lifetime">
            <title>JWT Cookie Lifetime</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Cookie and JWT expiration.</strong> Both the HTTP cookies and the JWT have expiration times.</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>For simplicity and consistency, the cookies and their containing JWT will expire at the same time. There’s
                                no need to have these be different values.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Given this, JWT cookies will always have expiration values, unlike <reference name="current Open edX session cookies that may have no expiration" refuri="https://github.com/openedx/edx-platform/blob/92030ea15216a6641c83dd7bb38a9b65112bf31a/common/djangoapps/student/cookies.py#L25-L27">current Open edX session cookies that may
                                    have no expiration</reference>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A configuration setting, JWT_AUTH_COOKIE_EXPIRATION, will specify the expiration duration for JWTs and their
                                containing cookie.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>Revocation with short-lived JWTs</strong> Given the tradeoff between long-lived JWTs versus immediacy of revocation, we
                        need to configure an appropriate expiration value for JWT cookies. In a future world with an API gateway, we <emphasis>may</emphasis>
                        have longer lived JWTs with a <emphasis>stateful</emphasis> check against a centralized <reference name="JWT blacklist" refuri="https://auth0.com/blog/blacklist-json-web-token-api-keys/">JWT blacklist</reference> and each JWT uniquely
                        identified by a <reference name="JWT ID (jti)" refuri="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#jtiDef">JWT ID (jti)</reference>. In the meantime, we will err on the side of security and have short-lived JWTs.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Refresh JWT Cookies.</strong> When a JWT expires, we do not want to ask the user to login again while their browser
                        session remains alive. A microfrontend will detect JWT expiration upon receiving a 401 response from an API
                        endpoint, or preemptively recognize an imminent expiration. To automatically refresh the JWT cookie, the
                        microfrontend will call a new endpoint (“refresh”) that returns a new JWT Cookie to keep the user’s session alive.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Remove JWT Cookie on Logout.</strong> When the user logs out, we will remove all JWT-related cookies in the response,
                        which will remove them from the user’s browser cookie jar. Thus, the user will be logged out of all the
                        microfrontends.</paragraph>
                </list_item>
            </enumerated_list>
            <target ids="current-open-edx-session-cookies-that-may-have-no-expiration" names="current\ open\ edx\ session\ cookies\ that\ may\ have\ no\ expiration" refuri="https://github.com/openedx/edx-platform/blob/92030ea15216a6641c83dd7bb38a9b65112bf31a/common/djangoapps/student/cookies.py#L25-L27"></target>
            <target ids="jwt-blacklist" names="jwt\ blacklist" refuri="https://auth0.com/blog/blacklist-json-web-token-api-keys/"></target>
            <target ids="jwt-id-jti" names="jwt\ id\ (jti)" refuri="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#jtiDef"></target>
        </section>
        <section ids="jwt-cookie-content" names="jwt\ cookie\ content">
            <title>JWT Cookie Content</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Minimize JWT size.</strong> According to the <reference name="HTTP Cookie RFC standard" refuri="https://tools.ietf.org/html/rfc6265">HTTP Cookie RFC standard</reference>, HTTP cookies <reference name="up to 4096 bytes" refuri="https://tools.ietf.org/html/rfc6265#section-6.1">up to 4096 bytes</reference> should be
                        supported by a browser. <reference name="Modern browsers have treated this requirement as a maximum" refuri="http://browsercookielimits.squawky.net/">Modern browsers have treated this requirement as a maximum</reference> - and hence do not support
                        more than 4096 bytes. Our current JWT size is about 970 bytes (varying with size of user identifiers, like user’s
                        name, etc). (Side note: Signing a JWT with a 2048 byte asymmetric key increases the JWT’s size by 325 bytes.)</paragraph>
                    <paragraph>To minimize the JWT’s size from the start, we should eliminate any unnecessary data that is <reference name="currently embedded in the JWT" refuri="https://github.com/openedx/edx-platform/blob/92030ea15216a6641c83dd7bb38a9b65112bf31a/openedx/core/lib/token_utils.py#L13">currently embedded
                            in the JWT</reference>. For example:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph><emphasis>aud</emphasis> - should remove this since we do not make use of the audience field.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>preferred_username</emphasis> - should be renamed simply to <emphasis>username</emphasis>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>administrator</emphasis> - can keep for now, but may eventually be replaced as <emphasis>role</emphasis> data - when we design
                                authorization.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </enumerated_list>
            <target ids="http-cookie-rfc-standard" names="http\ cookie\ rfc\ standard" refuri="https://tools.ietf.org/html/rfc6265"></target>
            <target ids="up-to-4096-bytes" names="up\ to\ 4096\ bytes" refuri="https://tools.ietf.org/html/rfc6265#section-6.1"></target>
            <target ids="modern-browsers-have-treated-this-requirement-as-a-maximum" names="modern\ browsers\ have\ treated\ this\ requirement\ as\ a\ maximum" refuri="http://browsercookielimits.squawky.net/"></target>
            <target ids="currently-embedded-in-the-jwt" names="currently\ embedded\ in\ the\ jwt" refuri="https://github.com/openedx/edx-platform/blob/92030ea15216a6641c83dd7bb38a9b65112bf31a/openedx/core/lib/token_utils.py#L13"></target>
        </section>
        <section ids="jwt-cookie-security" names="jwt\ cookie\ security">
            <title>JWT Cookie Security</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Enable CSRF Protection.</strong> Storing JWTs in HTTP cookies is potentially vulnerable to CSRF attacks.
                        See <reference name="JWT Cookie Storage Security" refuri="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage#so-whats-the-difference">JWT Cookie Storage Security</reference>. To protect against this:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>Enable the <reference name="HttpOnly" refuri="https://www.owasp.org/index.php/HttpOnly">HttpOnly</reference> flag on the <strong>“JWT Signature Cookie”</strong>, so Javascript code cannot misuse the JWT.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Enable the <reference name="Secure" refuri="https://www.owasp.org/index.php/SecureFlag">Secure</reference> flag on the cookie, so it will not be sent (and thus leaked) through an unencrypted channel.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Enable <reference name="Django's CSRF middleware" refuri="https://docs.djangoproject.com/en/1.11/ref/csrf/">Django’s CSRF middleware</reference> for every response.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Ensure all GET requests are side-effect free.</paragraph>
                            <bullet_list bullet="*">
                                <list_item>
                                    <paragraph>Note: The <reference name="same-origin policy" refuri="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</reference> protects against CSRF attacks on GET requests since the rogue website cannot
                                        access the response from the GET request.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>However, even though the rogue website cannot access the response, the GET request is still processed on the
                                        server before returning the response. So we need to ensure there are no unwanted side-effects on the server.</paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>CORS and withCredentials.</strong> <reference name="Cross-origin resource sharing (CORS)" refuri="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross-origin resource sharing (CORS)</reference> will need to be configured so that all allowed
                        microfrontends can access the necessary backend microservices. In addition, microfrontends will need to set the
                        <reference name="withCredentials" refuri="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</reference> attribute so that the JWT Cookie gets sent when API calls are made.</paragraph>
                    <paragraph>Note: We cannot selectively choose which cookies are sent so all edX-issued cookies will be sent with these API
                        calls. Apparently, we already send all edX cookies on API requests today, so this will not cause a significant
                        performance issue.</paragraph>
                </list_item>
            </enumerated_list>
            <target ids="jwt-cookie-storage-security" names="jwt\ cookie\ storage\ security" refuri="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage#so-whats-the-difference"></target>
            <target ids="httponly" names="httponly" refuri="https://www.owasp.org/index.php/HttpOnly"></target>
            <target ids="secure" names="secure" refuri="https://www.owasp.org/index.php/SecureFlag"></target>
            <target ids="django-s-csrf-middleware" names="django's\ csrf\ middleware" refuri="https://docs.djangoproject.com/en/1.11/ref/csrf/"></target>
            <target ids="same-origin-policy" names="same-origin\ policy" refuri="https://en.wikipedia.org/wiki/Same-origin_policy"></target>
            <target ids="cross-origin-resource-sharing-cors" names="cross-origin\ resource\ sharing\ (cors)" refuri="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing"></target>
            <target ids="withcredentials" names="withcredentials" refuri="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials"></target>
        </section>
    </section>
    <section ids="consequences" names="consequences">
        <title>Consequences</title>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph>Since HTTP cookies have a limited size of <reference name="at least 4096 bytes" refuri="http://browsercookielimits.squawky.net/">at least 4096 bytes</reference>, we will need to monitor its size increase
                    over time and implement a warning before it exceeds the size. Having this hard limit requires us to be judicious
                    of what data is included in the JWT. A bloated JWT is not necessarily a benefit to overall web performance.</paragraph>
                <paragraph>Separating the JWT into two, specifically its large signature, mitigates this issue significantly.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Rejected Alternative: Instead of storing JWTs in cookies, microfrontends could store them in HTML5 Web Storage.
                    However, that is vulnerable to XSS attacks as described in <reference name="JWT sessionStorage and localStorage Security" refuri="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage#so-whats-the-difference">JWT sessionStorage and localStorage Security</reference>.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Since the <strong>“JWT Header/Payload Cookie”</strong> is accessible to the microfrontend JS code, it allows the microfrontend
                    to get user information directly and immediately from the cookie.</paragraph>
                <paragraph>We rejected the following alternatives for accessing this user information:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Add an extra round trip to get the user-data from a backend API, and then cache it in HTML5 Storage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Continue to use and expand the current <reference name="JS-accessible user-info cookie" refuri="https://github.com/openedx/edx-platform/blob/70d1ca474012b89e4c7184d25499eb87b3135409/common/djangoapps/student/cookies.py#L151">JS-accessible user-info cookie</reference>, which contains user-data.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Have the server populate the initial DOM with this data, but this would only work for server-generated HTML.</paragraph>
                    </list_item>
                </enumerated_list>
            </list_item>
        </enumerated_list>
        <target ids="at-least-4096-bytes" names="at\ least\ 4096\ bytes" refuri="http://browsercookielimits.squawky.net/"></target>
        <target ids="jwt-sessionstorage-and-localstorage-security" names="jwt\ sessionstorage\ and\ localstorage\ security" refuri="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage#so-whats-the-difference"></target>
        <target ids="js-accessible-user-info-cookie" names="js-accessible\ user-info\ cookie" refuri="https://github.com/openedx/edx-platform/blob/70d1ca474012b89e4c7184d25499eb87b3135409/common/djangoapps/student/cookies.py#L151"></target>
    </section>
    <section ids="references" names="references">
        <title>References</title>
        <bullet_list bullet="*">
            <list_item>
                <paragraph><reference refuri="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage">https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage</reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference refuri="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide">https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide</reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference refuri="http://www.redotheweb.com/2015/11/09/api-security.html">http://www.redotheweb.com/2015/11/09/api-security.html</reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference refuri="http://flask-jwt-extended.readthedocs.io/en/latest/tokens_in_cookies.html">http://flask-jwt-extended.readthedocs.io/en/latest/tokens_in_cookies.html</reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference refuri="https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3">https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3</reference></paragraph>
            </list_item>
        </bullet_list>
    </section>
    <section ids="change-history" names="change\ history">
        <title>Change history</title>
        <section ids="id1" names="2023-11-08">
            <title>2023-11-08</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Added updated implementation notes since USE-JWT-COOKIE header was replaced with “forgiving JWTs”, a different implementation that solves the same problem.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id2" names="2019-09-04">
            <title>2019-09-04</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Added notes about new JwtRedirectToLoginIfUnauthenticatedMiddleware, and other minor changes.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id3" names="2019-03-12">
            <title>2019-03-12</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Removed details about a refresh cookie, since the LMS as identity provider’s session was used instead.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id4" names="2018-11-27">
            <title>2018-11-27</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Introduce USE-JWT-COOKIE header to solve backward compatability issue.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id5" names="2018-09-17">
            <title>2018-09-17</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Original ADR</paragraph>
                </list_item>
            </bullet_list>
        </section>
    </section>
</document>
