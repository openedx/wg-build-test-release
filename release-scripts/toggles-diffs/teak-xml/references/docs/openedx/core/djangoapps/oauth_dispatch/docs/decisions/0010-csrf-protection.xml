<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/openedx/edx-platform/docs/references/docs/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0010-csrf-protection.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="dealing-with-django-csrf-protection-in-frontend-apps" names="10.\ dealing\ with\ django\ csrf\ protection\ in\ frontend\ apps">
        <title>10. Dealing with Django CSRF Protection in Frontend Apps</title>
    </section>
    <section ids="status" names="status">
        <title>Status</title>
        <paragraph>Accepted</paragraph>
    </section>
    <section ids="context" names="context">
        <title>Context</title>
        <paragraph>For background, please see:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph><reference name="Transport JWT in HTTP Cookies" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0009-jwt-in-session-cookie.rst">Transport JWT in HTTP Cookies</reference>, where we decided the mechanism that frontend apps will use to authenticate with
                    backend API services.</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference name="Django CSRF Protection" refuri="https://docs.djangoproject.com/en/2.1/ref/csrf/">Django CSRF Protection</reference>, which contains a description of Django’s CSRF protection.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Frontend apps need a way to obtain a CSRF token when making POST, PUT, and DELETE requests to backend API services
            implemented as Django applications with CSRF protection enabled. Each backend service is generally deployed with a CSRF
            token cookie scoped to the domain of the given service (ecommerce.edx.org) and named accordingly (ecommerce_csrftoken).
            Each backend service uses a unique SECRET_KEY to produce the CSRF token, so a CSRF token created by one service will not
            be valid for another service. Therefore, frontend apps served by different subdomains will not have access to these CSRF
            token cookies.</paragraph>
        <target ids="transport-jwt-in-http-cookies" names="transport\ jwt\ in\ http\ cookies" refuri="https://github.com/openedx/edx-platform/blob/master/openedx/core/djangoapps/oauth_dispatch/docs/decisions/0009-jwt-in-session-cookie.rst"></target>
        <target ids="django-csrf-protection" names="django\ csrf\ protection" refuri="https://docs.djangoproject.com/en/2.1/ref/csrf/"></target>
    </section>
    <section ids="decisions" names="decisions">
        <title>Decisions</title>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph><strong>CSRF Token API Endpoint</strong> We will implement an API view that constructs a valid CSRF token and returns
                    it in a JSON response. This API view will be added to the <reference name="edx-drf-extensions" refuri="https://github.com/openedx/edx-drf-extensions">edx-drf-extensions</reference> python library under a
                    new “csrf” Django app which will be added to INSTALLED_APPS in each backend service as we encounter
                    frontend apps that need to make POST, PUT, and DELETE API requests to a given backend service. The CSRF token API
                    endpoint will be protected from cross-domain XHR requests using our standard CORS protections (only requests
                    originating from pages loaded from one of the domains listed in the CORS_ORIGIN_WHITELIST setting will be
                    allowed).</paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>Shared HTTP Client CSRF Token Management Code</strong> We will add code to the <reference name="@edx/frontend-auth" refuri="https://github.com/openedx/frontend-auth">@edx/frontend-auth</reference> npm package
                    that applies a request interceptor to the Axios HTTP client which will ensure that any POST, PUT, and DELETE
                    requests are made with the appropriate CSRF token header. This code will make use of the the CSRF token API
                    Endpoint described above to obtain a valid CSRF token for the given backend service for which a request is
                    being made.</paragraph>
            </list_item>
        </enumerated_list>
        <target ids="edx-drf-extensions" names="edx-drf-extensions" refuri="https://github.com/openedx/edx-drf-extensions"></target>
        <target ids="edx-frontend-auth" names="@edx/frontend-auth" refuri="https://github.com/openedx/frontend-auth"></target>
    </section>
    <section ids="rejected-alternatives" names="rejected\ alternatives">
        <title>Rejected Alternatives</title>
        <section ids="shared-secret-key-across-backend-services" names="shared\ secret_key\ across\ backend\ services">
            <title>Shared SECRET_KEY Across Backend Services</title>
            <paragraph>One alternative to the solution outlined above would be to share the configured SECRET_KEY setting value
                across all backend services and change the CSRF_COOKIE_DOMAIN value to a wildcard off of the second-level
                domain of the Open edX installation (e.g. .edx.org). This would allow frontend apps to read the CSRF token
                from the cookie that is set when a user logs via the authentication service (currently LMS). Since the
                SECRET_KEY value would be shared across all backend services, the frontend would be able to use the same
                CSRF token to make POST, PUT, and DELETE API requests to each of these services.</paragraph>
            <paragraph>We rejected this alternative due to the fact that it seems more secure to limit the exposure of the SECRET_KEY
                value to a single service.</paragraph>
        </section>
    </section>
    <section ids="references" names="references">
        <title>References</title>
        <bullet_list bullet="*">
            <list_item>
                <paragraph><reference refuri="https://fractalideas.com/blog/making-react-and-django-play-well-together-single-page-app-model/">https://fractalideas.com/blog/making-react-and-django-play-well-together-single-page-app-model/</reference></paragraph>
            </list_item>
        </bullet_list>
    </section>
</document>
