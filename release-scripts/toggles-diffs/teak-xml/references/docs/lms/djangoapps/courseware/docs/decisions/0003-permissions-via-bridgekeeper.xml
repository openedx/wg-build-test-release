<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/Users/sarinacanelake/openedx/edx-platform/docs/references/docs/lms/djangoapps/courseware/docs/decisions/0003-permissions-via-bridgekeeper.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:http="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="use-bridgekeeper-for-permissions-and-tracks" names="0003.\ use\ bridgekeeper\ for\ permissions\ and\ tracks">
        <title>0003. Use <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> for Permissions and Tracks</title>
        <section ids="context" names="context">
            <title>Context</title>
            <paragraph>In <reference name="0002. Use django-rules for Permissions and Tracks" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/docs/decisions/0002-permissions-via-django-rules.rst">0002. Use django-rules for Permissions and Tracks</reference>, the case was
                laid out for using <reference name="django-rules" refuri="https://github.com/dfunckt/django-rules">django-rules</reference> to manage permissions. In the intervening
                time, no active work has been done to complete the conversion. During that
                period, authorization checking was observed to be a significant performance
                in several list views of courses (the CourseListView from course_api and
                the student dashboard view). In both cases, access checking had to be performed
                after the CourseOverview had been loaded from the database, and resulted
                in significant numbers of additional queries.</paragraph>
            <paragraph><reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> is a library with an interface that is very similar to
                <reference name="django-rules" refuri="https://github.com/dfunckt/django-rules">django-rules</reference>, except that it also supports specifying the permissions
                as Django query filters. By inspection, it seems to support non-boolean
                return values for the Python-based permissions checks.</paragraph>
            <target ids="bridgekeeper" names="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html"></target>
            <target ids="django-rules" names="django-rules" refuri="https://github.com/dfunckt/django-rules"></target>
        </section>
        <section ids="decision" names="decision">
            <title>Decision</title>
            <paragraph>Rather than use <reference name="django-rules" refuri="https://github.com/dfunckt/django-rules">django-rules</reference> in edx-platform, we will convert permissions
                checks to use <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference>. The conversion will follow a similar outline
                to the plan in <reference name="0002" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/docs/decisions/0002-permissions-via-django-rules.rst">0002</reference>.</paragraph>
            <paragraph>We will update all uses of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference>, and all <problematic ids="id3" refid="id2">`CourseMode`_</problematic> membership
                checks, to use <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> and named permissions.</paragraph>
            <target ids="use-django-rules-for-permissions-and-tracks" names="0002.\ use\ django-rules\ for\ permissions\ and\ tracks" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/docs/decisions/0002-permissions-via-django-rules.rst"></target>
            <target ids="id1" names="0002" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/docs/decisions/0002-permissions-via-django-rules.rst"></target>
            <section ids="plan-of-action" names="plan\ of\ action">
                <title>Plan of Action</title>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>For each caller of <literal>has_access</literal>:</paragraph>
                        <enumerated_list enumtype="arabic" prefix="" suffix=".">
                            <list_item>
                                <paragraph>Convert the caller to use <literal>user.has_perm</literal> instead.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Implement the new permission created in 1. by referencing to the
                                    previous <literal>has_access</literal> call. These <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> rules would implement
                                    <literal>query</literal> to raise an exception when called, and implement <literal>check</literal>
                                    to pass through to <literal>has_access</literal>.</paragraph>
                            </list_item>
                        </enumerated_list>
                    </list_item>
                    <list_item>
                        <paragraph>Refactor contents of <literal>has_access</literal> out into their own predicates that can
                            be used to implement specific permissions. Where possible, implement
                            <literal>query</literal>, either manually by specifying a custom rule, or by using
                            <literal>Attribute</literal> or <literal>Relation</literal> from <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For any listing views that are currently checking access as a filter
                            after querying the database, improve their performance by using the
                            <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> permission to filter the queryset instead. If those
                            views need to display the existence (but not contents) of the object,
                            two separate permissions can be used: the first to limit the query
                            to only those objects to be displayed, and the second to check whether
                            the user has permissions to view the contents of the object.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For each place that checks if a user is enrolled in a specific track:</paragraph>
                        <enumerated_list enumtype="arabic" prefix="" suffix=".">
                            <list_item>
                                <paragraph>Convert the that check to use <literal>user.has_perm</literal> for a named permission</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Implement that permission by checking</paragraph>
                            </list_item>
                        </enumerated_list>
                    </list_item>
                </enumerated_list>
            </section>
            <section ids="details" names="details">
                <title>Details</title>
                <section ids="convert-callers-of-has-access-to-use-user-has-perm" names="convert\ callers\ of\ has_access\ to\ use\ user.has_perm">
                    <title>Convert callers of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> to use <reference name="user.has_perm" refuri="https://docs.djangoproject.com/en/2.1/ref/contrib/auth/#django.contrib.auth.models.User.has_perm">user.has_perm</reference></title>
                    <paragraph>Currently, the LMS uses <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> to check if a given user has a particular
                        role on a particular object (usually a course or an xblock). From that, it
                        assumes various permissions. The primary goal of this project is to convert
                        those implicit permissions into explicit named permissions that are tied
                        to roles by the use of various predicates.</paragraph>
                    <paragraph>To bootstrap this process, we can wrap <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> in named permissions by:</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>Convert each caller of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> to use <reference name="user.has_perm" refuri="https://docs.djangoproject.com/en/2.1/ref/contrib/auth/#django.contrib.auth.models.User.has_perm">user.has_perm</reference> instead.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Implement the new permission created in 1. by referencing to the previous
                                <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> call.</paragraph>
                        </list_item>
                    </enumerated_list>
                    <paragraph>This work can be done incrementally, one call to <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> at a time,
                        and can be parallelized. However, at present, there are ~150 calls to
                        <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> in edx-platform, so this is not an insignificant amount of
                        work.</paragraph>
                    <target ids="has-access" names="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103"></target>
                    <target ids="user-has-perm" names="user.has_perm" refuri="https://docs.djangoproject.com/en/2.1/ref/contrib/auth/#django.contrib.auth.models.User.has_perm"></target>
                </section>
                <section ids="refactor-contents-of-has-access" names="refactor\ contents\ of\ has_access">
                    <title>Refactor contents of <literal>has_access</literal></title>
                    <paragraph>As implemented, <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> has many subclauses to handle the various
                        roles and object types. With <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference>, those clauses could be converted
                        to smaller individual Rules, either divided by roles, object types,
                        or both. These predicates would then be simpler to test and to use in
                        determining future permissions.</paragraph>
                </section>
                <section ids="convert-track-membership-tests-to-permissions" names="convert\ track\ membership\ tests\ to\ permissions">
                    <title>Convert track membership tests to permissions</title>
                    <paragraph>Future work in the same vein would be to convert current usage of track
                        membership into <reference name="user.has_perm" refuri="https://docs.djangoproject.com/en/2.1/ref/contrib/auth/#django.contrib.auth.models.User.has_perm">user.has_perm</reference> checks. This would allow disaggregation
                        of edx-platform features and would make it easier to add new tracks
                        with variations of those features.</paragraph>
                </section>
            </section>
            <section ids="offramps" names="offramps">
                <title>Offramps</title>
                <paragraph>The primary offramp would be suspending the project after converting all
                    callers of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> to use <reference name="user.has_perm" refuri="https://docs.djangoproject.com/en/2.1/ref/contrib/auth/#django.contrib.auth.models.User.has_perm">user.has_perm</reference>. If we have more time,
                    then refactoring <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> would be a definite positive, but not
                    required. If we are forced to cut scope, then only partially completing
                    the conversion of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> would be an improvement, perhaps with
                    the addition of deprecation warnings for direct callers to <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference>
                    so that we can track the remaining work with INCR tickets.</paragraph>
            </section>
        </section>
        <section ids="status" names="status">
            <title>Status</title>
            <paragraph>Proposed</paragraph>
        </section>
        <section ids="consequences" names="consequences">
            <title>Consequences</title>
            <paragraph>When the conversion of <reference name="has_access" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py#L103">has_access</reference> has been completed, it will be easier
                to add additional conditions to various permissions checks on specific objects.
                It will also allow those conditions (predicates) to be written in
                a location that is central to the app they are responsible for, rather
                than requiring that they be added to <reference name="access.py" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py">access.py</reference>.</paragraph>
            <target ids="access-py" names="access.py" refuri="https://github.com/openedx/edx-platform/blob/master/lms/djangoapps/courseware/access.py"></target>
            <paragraph>When the conversion of <problematic ids="id5" refid="id4">`CourseMode`_</problematic> membership checks has been completed,
                it will be easier to add new <problematic ids="id7" refid="id6">`CourseMode`_</problematic> types with similar permissions
                schema to the codebase. It will also open the way towards making <problematic ids="id9" refid="id8">`CourseMode`_</problematic>
                permissions be data-driven, rather than being code specific, which would
                allow configuration-time specification of <problematic ids="id11" refid="id10">`CourseMode`_</problematic>, rather than requiring
                the current combination of code and database entries.</paragraph>
            <paragraph>Converting all of these checks to use <reference name="bridgekeeper" refuri="https://bridgekeeper.readthedocs.io/en/latest/index.html">bridgekeeper</reference> will allow list-view
                query performance to be optimized.</paragraph>
        </section>
    </section>
</document>
